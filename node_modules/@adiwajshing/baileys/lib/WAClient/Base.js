"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var WAConnection_1 = __importDefault(require("../WAConnection/WAConnection"));
var Constants_1 = require("./Constants");
var Constants_2 = require("../WAConnection/Constants");
var Utils_1 = require("../WAConnection/Utils");
var WhatsAppWebBase = /** @class */ (function (_super) {
    __extends(WhatsAppWebBase, _super);
    function WhatsAppWebBase() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Query whether a given number is registered on WhatsApp */
        _this.isOnWhatsApp = function (jid) { return _this.query(['query', 'exist', jid]).then(function (m) { return m.status === 200; }); };
        /** Request an update on the presence of a user */
        _this.requestPresenceUpdate = function (jid) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/, this.queryExpecting200(['action', 'presence', 'subscribe', jid])
                /** Query the status of the person (see groupMetadata() for groups) */
            ];
        }); }); };
        /** Get the metadata of the group */
        _this.groupMetadata = function (jid) { return _this.queryExpecting200(['query', 'GroupMetadata', jid]); };
        /**
         * Create a group
         * @param title like, the title of the group
         * @param participants people to include in the group
         */
        _this.groupCreate = function (title, participants) {
            return _this.groupQuery('create', null, title, participants);
        };
        /**
         * Leave a group
         * @param jid the ID of the group
         */
        _this.groupLeave = function (jid) { return _this.groupQuery('leave', jid); };
        /**
         * Update the subject of the group
         * @param {string} jid the ID of the group
         * @param {string} title the new title of the group
         */
        _this.groupUpdateSubject = function (jid, title) {
            return _this.groupQuery('subject', jid, title);
        };
        /**
         * Add somebody to the group
         * @param jid the ID of the group
         * @param participants the people to add
         */
        _this.groupAdd = function (jid, participants) {
            return _this.groupQuery('add', jid, null, participants);
        };
        /**
         * Remove somebody from the group
         * @param jid the ID of the group
         * @param participants the people to remove
         */
        _this.groupRemove = function (jid, participants) {
            return _this.groupQuery('remove', jid, null, participants);
        };
        /**
         * Make someone admin on the group
         * @param jid the ID of the group
         * @param participants the people to make admin
         */
        _this.groupMakeAdmin = function (jid, participants) {
            return _this.groupQuery('promote', jid, null, participants);
        };
        return _this;
    }
    /** Set the callback for unexpected disconnects */
    WhatsAppWebBase.prototype.setOnUnexpectedDisconnect = function (callback) {
        var _this = this;
        this.unexpectedDisconnect = function (err) {
            _this.close();
            callback(err);
        };
    };
    /** Set the callback for message status updates (when a message is delivered, read etc.) */
    WhatsAppWebBase.prototype.setOnMessageStatusChange = function (callback) {
        var func = function (json) {
            json = json[1];
            var ids = json.id;
            if (json.cmd === 'ack') {
                ids = [json.id];
            }
            var ackTypes = [Constants_1.MessageStatus.sent, Constants_1.MessageStatus.received, Constants_1.MessageStatus.read];
            var data = {
                from: json.from,
                to: json.to,
                participant: json.participant,
                timestamp: new Date(json.t * 1000),
                ids: ids,
                type: ackTypes[json.ack - 1] || 'unknown (' + json.ack + ')',
            };
            callback(data);
        };
        this.registerCallback('Msg', func);
        this.registerCallback('MsgInfo', func);
    };
    /**
     * Set the callback for new/unread messages; if someone sends you a message, this callback will be fired
     * @param callbackOnMyMessages - should the callback be fired on a message you sent from the phone
     */
    WhatsAppWebBase.prototype.setOnUnreadMessage = function (callbackOnMyMessages, callback) {
        var _this = this;
        if (callbackOnMyMessages === void 0) { callbackOnMyMessages = false; }
        this.registerCallback(['action', 'add:relay', 'message'], function (json) {
            var message = json[2][0][2];
            if (!message.key.fromMe || callbackOnMyMessages) {
                // if this message was sent to us, notify
                callback(message);
            }
            else if (_this.logLevel >= Constants_2.MessageLogLevel.unhandled) {
                _this.log("[Unhandled] message - " + JSON.stringify(message));
            }
        });
    };
    /** Set the callback for presence updates; if someone goes offline/online, this callback will be fired */
    WhatsAppWebBase.prototype.setOnPresenceUpdate = function (callback) {
        this.registerCallback('Presence', function (json) { return callback(json[1]); });
    };
    /**
     * Tell someone about your presence -- online, typing, offline etc.
     * @param jid the ID of the person/group who you are updating
     * @param type your presence
     */
    WhatsAppWebBase.prototype.updatePresence = function (jid, type) {
        return __awaiter(this, void 0, void 0, function () {
            var json;
            return __generator(this, function (_a) {
                json = [
                    'action',
                    { epoch: this.msgCount.toString(), type: 'set' },
                    [['presence', { type: type, to: jid }, null]],
                ];
                return [2 /*return*/, this.queryExpecting200(json, [Constants_2.WAMetric.group, Constants_2.WAFlag.acknowledge])];
            });
        });
    };
    /** Query the status of the person (see groupMetadata() for groups) */
    WhatsAppWebBase.prototype.getStatus = function (jid) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.query(['query', 'Status', jid || this.userMetaData.id])];
            });
        });
    };
    /** Get the URL to download the profile picture of a person/group */
    WhatsAppWebBase.prototype.getProfilePicture = function (jid) {
        return __awaiter(this, void 0, void 0, function () {
            var response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.queryExpecting200(['query', 'ProfilePicThumb', jid || this.userMetaData.id])];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.eurl];
                }
            });
        });
    };
    /** Get your contacts */
    WhatsAppWebBase.prototype.getContacts = function () {
        return __awaiter(this, void 0, void 0, function () {
            var json, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        json = ['query', { epoch: this.msgCount.toString(), type: 'contacts' }, null];
                        return [4 /*yield*/, this.query(json, [Constants_2.WAMetric.group, Constants_2.WAFlag.ignore])]; // this has to be an encrypted query
                    case 1:
                        response = _a.sent() // this has to be an encrypted query
                        ;
                        console.log(response);
                        return [2 /*return*/, response];
                }
            });
        });
    };
    /** Fetch your chats */
    WhatsAppWebBase.prototype.getChats = function () {
        var json = ['query', { epoch: this.msgCount.toString(), type: 'chat' }, null];
        return this.query(json, [Constants_2.WAMetric.group, Constants_2.WAFlag.ignore]); // this has to be an encrypted query
    };
    /**
     * Archive a given chat
     * @param jid the ID of the person/group you are archiving
     */
    WhatsAppWebBase.prototype.archiveChat = function (jid) {
        return __awaiter(this, void 0, void 0, function () {
            var json;
            return __generator(this, function (_a) {
                json = [
                    'action',
                    { epoch: this.msgCount.toString(), type: 'set' },
                    [['chat', { type: 'archive', jid: jid }, null]],
                ];
                return [2 /*return*/, this.queryExpecting200(json, [Constants_2.WAMetric.group, Constants_2.WAFlag.acknowledge])];
            });
        });
    };
    /**
     * Check if your phone is connected
     * @param timeoutMs max time for the phone to respond
     */
    WhatsAppWebBase.prototype.isPhoneConnected = function (timeoutMs) {
        if (timeoutMs === void 0) { timeoutMs = 5000; }
        return __awaiter(this, void 0, void 0, function () {
            var response, error_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.query(['admin', 'test'], null, timeoutMs)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response[1]];
                    case 2:
                        error_1 = _a.sent();
                        return [2 /*return*/, false];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Load the conversation with a group or person
     * @param count the number of messages to load
     * @param [indexMessage] the data for which message to offset the query by
     * @param [mostRecentFirst] retreive the most recent message first or retreive from the converation start
     */
    WhatsAppWebBase.prototype.loadConversation = function (jid, count, indexMessage, mostRecentFirst) {
        if (indexMessage === void 0) { indexMessage = null; }
        if (mostRecentFirst === void 0) { mostRecentFirst = true; }
        return __awaiter(this, void 0, void 0, function () {
            var json, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        json = [
                            'query',
                            {
                                epoch: this.msgCount.toString(),
                                type: 'message',
                                jid: jid,
                                kind: mostRecentFirst ? 'before' : 'after',
                                count: count.toString(),
                                index: indexMessage === null || indexMessage === void 0 ? void 0 : indexMessage.id,
                                owner: (indexMessage === null || indexMessage === void 0 ? void 0 : indexMessage.fromMe) === false ? 'false' : 'true',
                            },
                            null,
                        ];
                        return [4 /*yield*/, this.query(json, [Constants_2.WAMetric.group, Constants_2.WAFlag.ignore])];
                    case 1:
                        response = _a.sent();
                        if (response.status)
                            throw new Error("error in query, got status: " + response.status);
                        return [2 /*return*/, response[2] ? response[2].map(function (item) { return item[2]; }) : []];
                }
            });
        });
    };
    /**
     * Load the entire friggin conversation with a group or person
     * @param onMessage callback for every message retreived
     * @param [chunkSize] the number of messages to load in a single request
     * @param [mostRecentFirst] retreive the most recent message first or retreive from the converation start
     */
    WhatsAppWebBase.prototype.loadEntireConversation = function (jid, onMessage, chunkSize, mostRecentFirst) {
        var _this = this;
        if (chunkSize === void 0) { chunkSize = 25; }
        if (mostRecentFirst === void 0) { mostRecentFirst = true; }
        var offsetID = null;
        var loadMessage = function () { return __awaiter(_this, void 0, void 0, function () {
            var json, lastMessage, i, i;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loadConversation(jid, chunkSize, offsetID, mostRecentFirst)
                        // callback with most recent message first (descending order of date)
                    ];
                    case 1:
                        json = _a.sent();
                        if (mostRecentFirst) {
                            for (i = json.length - 1; i >= 0; i--) {
                                onMessage(json[i]);
                                lastMessage = json[i];
                            }
                        }
                        else {
                            for (i = 0; i < json.length; i++) {
                                onMessage(json[i]);
                                lastMessage = json[i];
                            }
                        }
                        // if there are still more messages
                        if (json.length >= chunkSize) {
                            offsetID = lastMessage.key; // get the last message
                            return [2 /*return*/, new Promise(function (resolve, reject) {
                                    // send query after 200 ms
                                    setTimeout(function () { return loadMessage().then(resolve).catch(reject); }, 200);
                                })];
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        return loadMessage();
    };
    /** Generic function for group queries */
    WhatsAppWebBase.prototype.groupQuery = function (type, jid, subject, participants) {
        var json = [
            'group',
            {
                author: this.userMetaData.id,
                id: Utils_1.generateMessageTag(),
                type: type,
                jid: jid,
                subject: subject,
            },
            participants ? participants.map(function (str) { return ['participant', { jid: str }, null]; }) : [],
        ];
        var q = ['action', { type: 'set', epoch: this.msgCount.toString() }, [json]];
        return this.queryExpecting200(q, [Constants_2.WAMetric.group, Constants_2.WAFlag.ignore]);
    };
    /** Get the invite link of the given group */
    WhatsAppWebBase.prototype.groupInviteCode = function (jid) {
        return __awaiter(this, void 0, void 0, function () {
            var json, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        json = ['query', 'inviteCode', jid];
                        return [4 /*yield*/, this.queryExpecting200(json)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.code];
                }
            });
        });
    };
    return WhatsAppWebBase;
}(WAConnection_1.default));
exports.default = WhatsAppWebBase;
