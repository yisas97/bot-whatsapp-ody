"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var ws_1 = __importDefault(require("ws"));
var Utils = __importStar(require("./Utils"));
var Constants_1 = require("./Constants");
var Validation_1 = __importDefault(require("./Validation"));
var WAConnectionConnector = /** @class */ (function (_super) {
    __extends(WAConnectionConnector, _super);
    function WAConnectionConnector() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Connect to WhatsAppWeb
     * @param [authInfo] credentials or path to credentials to log back in
     * @param [timeoutMs] timeout after which the connect will fail, set to null for an infinite timeout
     * @return returns [userMetaData, chats, contacts, unreadMessages]
     */
    WAConnectionConnector.prototype.connect = function (authInfo, timeoutMs) {
        if (authInfo === void 0) { authInfo = null; }
        if (timeoutMs === void 0) { timeoutMs = null; }
        return __awaiter(this, void 0, void 0, function () {
            var userInfo, chats;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.connectSlim(authInfo, timeoutMs)];
                    case 1:
                        userInfo = _a.sent();
                        return [4 /*yield*/, this.receiveChatsAndContacts(timeoutMs)];
                    case 2:
                        chats = _a.sent();
                        return [2 /*return*/, __spreadArrays([userInfo], chats)];
                }
            });
        });
    };
    /**
     * Connect to WhatsAppWeb, resolves without waiting for chats & contacts
     * @param [authInfo] credentials to log back in
     * @param [timeoutMs] timeout after which the connect will fail, set to null for an infinite timeout
     * @return [userMetaData, chats, contacts, unreadMessages]
     */
    WAConnectionConnector.prototype.connectSlim = function (authInfo, timeoutMs) {
        if (authInfo === void 0) { authInfo = null; }
        if (timeoutMs === void 0) { timeoutMs = null; }
        return __awaiter(this, void 0, void 0, function () {
            var promise;
            var _this = this;
            return __generator(this, function (_a) {
                // if we're already connected, throw an error
                if (this.conn) {
                    throw [1, 'already connected or connecting'];
                }
                // set authentication credentials if required
                try {
                    this.loadAuthInfoFromBase64(authInfo);
                }
                catch (_b) { }
                this.conn = new ws_1.default('wss://web.whatsapp.com/ws', null, { origin: 'https://web.whatsapp.com' });
                promise = new Promise(function (resolve, reject) {
                    _this.conn.on('open', function () {
                        _this.log('connected to WhatsApp Web, authenticating...');
                        // start sending keep alive requests (keeps the WebSocket alive & updates our last seen)
                        _this.authenticate()
                            .then(function (user) {
                            _this.startKeepAliveRequest();
                            resolve(user);
                        })
                            .catch(reject);
                    });
                    _this.conn.on('message', function (m) { return _this.onMessageRecieved(m); }); // in WhatsAppWeb.Recv.js
                    _this.conn.on('error', function (error) {
                        // if there was an error in the WebSocket
                        _this.close();
                        reject(error);
                    });
                });
                promise = Utils.promiseTimeout(timeoutMs, promise);
                return [2 /*return*/, promise.catch(function (err) {
                        _this.close();
                        throw err;
                    })];
            });
        });
    };
    /**
     * Sets up callbacks to receive chats, contacts & unread messages.
     * Must be called immediately after connect
     * @returns [chats, contacts, unreadMessages]
     */
    WAConnectionConnector.prototype.receiveChatsAndContacts = function (timeoutMs) {
        if (timeoutMs === void 0) { timeoutMs = null; }
        return __awaiter(this, void 0, void 0, function () {
            var chats, contacts, unreadMessages, unreadMap, receivedContacts, receivedMessages, convoResolve, waitForConvos, waitForChats, waitForContacts, promise;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        chats = [];
                        contacts = [];
                        unreadMessages = [];
                        unreadMap = {};
                        receivedContacts = false;
                        receivedMessages = false;
                        this.log('waiting for chats & contacts'); // wait for the message with chats
                        waitForConvos = function () {
                            return new Promise(function (resolve) {
                                convoResolve = function () {
                                    // de-register the callbacks, so that they don't get called again
                                    _this.deregisterCallback(['action', 'add:last']);
                                    _this.deregisterCallback(['action', 'add:before']);
                                    _this.deregisterCallback(['action', 'add:unread']);
                                    resolve();
                                };
                                var chatUpdate = function (json) {
                                    receivedMessages = true;
                                    var isLast = json[1].last;
                                    json = json[2];
                                    if (json) {
                                        for (var k = json.length - 1; k >= 0; k--) {
                                            var message = json[k][2];
                                            var jid = message.key.remoteJid.replace('@s.whatsapp.net', '@c.us');
                                            if (!message.key.fromMe && unreadMap[jid] > 0) {
                                                // only forward if the message is from the sender
                                                unreadMessages.push(message);
                                                unreadMap[jid] -= 1; // reduce
                                            }
                                        }
                                    }
                                    if (isLast && receivedContacts) { // if received contacts before messages
                                        convoResolve();
                                    }
                                };
                                // wait for actual messages to load, "last" is the most recent message, "before" contains prior messages
                                _this.registerCallback(['action', 'add:last'], chatUpdate);
                                _this.registerCallback(['action', 'add:before'], chatUpdate);
                                _this.registerCallback(['action', 'add:unread'], chatUpdate);
                            });
                        };
                        waitForChats = function () { return __awaiter(_this, void 0, void 0, function () {
                            var json;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.registerCallbackOneTime(['response', 'type:chat'])];
                                    case 1:
                                        json = _a.sent();
                                        json[2].forEach(function (chat) {
                                            chats.push(chat[1]); // chats data (log json to see what it looks like)
                                            // store the number of unread messages for each sender
                                            unreadMap[chat[1].jid] = chat[1].count;
                                        });
                                        if (chats.length > 0)
                                            return [2 /*return*/, waitForConvos()];
                                        return [2 /*return*/];
                                }
                            });
                        }); };
                        waitForContacts = function () { return __awaiter(_this, void 0, void 0, function () {
                            var json;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, this.registerCallbackOneTime(['response', 'type:contacts'])];
                                    case 1:
                                        json = _a.sent();
                                        contacts = json[2].map(function (item) { return item[1]; });
                                        receivedContacts = true;
                                        // if you receive contacts after messages
                                        // should probably resolve the promise
                                        if (receivedMessages)
                                            convoResolve();
                                        return [2 /*return*/];
                                }
                            });
                        }); };
                        promise = Promise.all([waitForChats(), waitForContacts()]);
                        return [4 /*yield*/, Utils.promiseTimeout(timeoutMs, promise)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, [chats, contacts, unreadMessages]];
                }
            });
        });
    };
    WAConnectionConnector.prototype.onMessageRecieved = function (message) {
        if (message[0] === '!') {
            // when the first character in the message is an '!', the server is updating the last seen
            var timestamp = message.slice(1, message.length);
            this.lastSeen = new Date(parseInt(timestamp));
        }
        else {
            var commaIndex = message.indexOf(','); // all whatsapp messages have a tag and a comma, followed by the actual message
            if (commaIndex < 0) {
                // if there was no comma, then this message must be not be valid
                throw [2, 'invalid message', message];
            }
            var data = message.slice(commaIndex + 1, message.length);
            // get the message tag.
            // If a query was done, the server will respond with the same message tag we sent the query with
            var messageTag = message.slice(0, commaIndex).toString();
            if (data.length === 0) {
                // got an empty message, usually get one after sending a query with the 128 tag
                return;
            }
            var json = void 0;
            if (data[0] === '[' || data[0] === '{') {
                // if the first character is a "[", then the data must just be plain JSON array or object
                json = JSON.parse(data); // parse the JSON
            }
            else if (this.authInfo.macKey && this.authInfo.encKey) {
                /*
                    If the data recieved was not a JSON, then it must be an encrypted message.
                    Such a message can only be decrypted if we're connected successfully to the servers & have encryption keys
                 */
                var checksum = data.slice(0, 32); // the first 32 bytes of the buffer are the HMAC sign of the message
                data = data.slice(32, data.length); // the actual message
                var computedChecksum = Utils.hmacSign(data, this.authInfo.macKey); // compute the sign of the message we recieved using our macKey
                if (checksum.equals(computedChecksum)) {
                    // the checksum the server sent, must match the one we computed for the message to be valid
                    var decrypted = Utils.aesDecrypt(data, this.authInfo.encKey); // decrypt using AES
                    json = this.decoder.read(decrypted); // decode the binary message into a JSON array
                }
                else {
                    throw [7, "checksums don't match"];
                }
            }
            else {
                // if we recieved a message that was encrypted but we don't have the keys, then there must be an error
                throw [3, 'recieved encrypted message when auth creds not available', message];
            }
            if (this.logLevel === Constants_1.MessageLogLevel.all) {
                this.log(messageTag + ', ' + JSON.stringify(json));
            }
            /*
             Check if this is a response to a message we sent
            */
            if (this.callbacks[messageTag]) {
                var q = this.callbacks[messageTag];
                q.callback(json);
                delete this.callbacks[messageTag];
                return;
            }
            /*
             Check if this is a response to a message we are expecting
            */
            if (this.callbacks['function:' + json[0]]) {
                var callbacks = this.callbacks['function:' + json[0]];
                var callbacks2 = void 0;
                var callback = void 0;
                for (var key in json[1] || {}) {
                    callbacks2 = callbacks[key + ':' + json[1][key]];
                    if (callbacks2) {
                        break;
                    }
                }
                if (!callbacks2) {
                    for (var key in json[1] || {}) {
                        callbacks2 = callbacks[key];
                        if (callbacks2) {
                            break;
                        }
                    }
                }
                if (!callbacks2) {
                    callbacks2 = callbacks[''];
                }
                if (callbacks2) {
                    callback = callbacks2[json[2] && json[2][0][0]];
                    if (!callback) {
                        callback = callbacks2[''];
                    }
                }
                if (callback) {
                    callback(json);
                    return;
                }
            }
            if (this.logLevel === Constants_1.MessageLogLevel.unhandled) {
                this.log('[Unhandled] ' + messageTag + ', ' + JSON.stringify(json));
            }
        }
    };
    /** Send a keep alive request every X seconds, server updates & responds with last seen */
    WAConnectionConnector.prototype.startKeepAliveRequest = function () {
        var _this = this;
        var refreshInterval = 20;
        this.keepAliveReq = setInterval(function () {
            var diff = (new Date().getTime() - _this.lastSeen.getTime()) / 1000;
            /*
                check if it's been a suspicious amount of time since the server responded with our last seen
                it could be that the network is down, or the phone got unpaired from our connection
            */
            if (diff > refreshInterval + 5) {
                _this.close();
                if (_this.autoReconnect) {
                    // attempt reconnecting if the user wants us to
                    _this.log('disconnected unexpectedly, reconnecting...');
                    var reconnectLoop_1 = function () { return _this.connect(null, 25 * 1000).catch(reconnectLoop_1); };
                    reconnectLoop_1(); // keep trying to connect
                }
                else {
                    _this.unexpectedDisconnect('lost connection unexpectedly');
                }
            }
            else {
                // if its all good, send a keep alive request
                _this.send('?,,');
            }
        }, refreshInterval * 1000);
    };
    return WAConnectionConnector;
}(Validation_1.default));
exports.default = WAConnectionConnector;
