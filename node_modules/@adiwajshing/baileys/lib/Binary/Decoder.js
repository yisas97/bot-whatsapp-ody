"use strict";
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var Constants_1 = require("./Constants");
var Decoder = /** @class */ (function () {
    function Decoder() {
        this.buffer = null;
        this.index = 0;
    }
    Decoder.prototype.checkEOS = function (length) {
        if (this.index + length > this.buffer.length) {
            throw 'end of stream';
        }
    };
    Decoder.prototype.next = function () {
        var value = this.buffer[this.index];
        this.index += 1;
        return value;
    };
    Decoder.prototype.readByte = function () {
        this.checkEOS(1);
        return this.next();
    };
    Decoder.prototype.readStringFromChars = function (length) {
        this.checkEOS(length);
        var value = this.buffer.slice(this.index, this.index + length);
        this.index += length;
        return new TextDecoder().decode(value);
    };
    Decoder.prototype.readBytes = function (n) {
        this.checkEOS(n);
        var value = this.buffer.slice(this.index, this.index + n);
        this.index += n;
        return value;
    };
    Decoder.prototype.readInt = function (n, littleEndian) {
        if (littleEndian === void 0) { littleEndian = false; }
        this.checkEOS(n);
        var val = 0;
        for (var i = 0; i < n; i++) {
            var shift = littleEndian ? i : n - 1 - i;
            val |= this.next() << (shift * 8);
        }
        return val;
    };
    Decoder.prototype.readInt20 = function () {
        this.checkEOS(3);
        return ((this.next() & 15) << 16) + (this.next() << 8) + this.next();
    };
    Decoder.prototype.unpackHex = function (value) {
        if (value >= 0 && value < 16) {
            return value < 10 ? '0'.charCodeAt(0) + value : 'A'.charCodeAt(0) + value - 10;
        }
        throw 'invalid hex: ' + value;
    };
    Decoder.prototype.unpackNibble = function (value) {
        if (value >= 0 && value <= 9) {
            return '0'.charCodeAt(0) + value;
        }
        switch (value) {
            case 10:
                return '-'.charCodeAt(0);
            case 11:
                return '.'.charCodeAt(0);
            case 15:
                return '\0'.charCodeAt(0);
            default:
                throw 'invalid nibble: ' + value;
        }
    };
    Decoder.prototype.unpackByte = function (tag, value) {
        if (tag === Constants_1.WA.Tags.NIBBLE_8) {
            return this.unpackNibble(value);
        }
        else if (tag === Constants_1.WA.Tags.HEX_8) {
            return this.unpackHex(value);
        }
        else {
            throw 'unknown tag: ' + tag;
        }
    };
    Decoder.prototype.readPacked8 = function (tag) {
        var startByte = this.readByte();
        var value = '';
        for (var i = 0; i < (startByte & 127); i++) {
            var curByte = this.readByte();
            value += String.fromCharCode(this.unpackByte(tag, (curByte & 0xf0) >> 4));
            value += String.fromCharCode(this.unpackByte(tag, curByte & 0x0f));
        }
        if (startByte >> 7 !== 0) {
            value = value.slice(0, -1);
        }
        return value;
    };
    Decoder.prototype.readRangedVarInt = function (min, max, description) {
        if (description === void 0) { description = 'unknown'; }
        // value =
        throw 'WTF; should not be called';
    };
    Decoder.prototype.isListTag = function (tag) {
        return tag === Constants_1.WA.Tags.LIST_EMPTY || tag === Constants_1.WA.Tags.LIST_8 || tag === Constants_1.WA.Tags.LIST_16;
    };
    Decoder.prototype.readListSize = function (tag) {
        switch (tag) {
            case Constants_1.WA.Tags.LIST_EMPTY:
                return 0;
            case Constants_1.WA.Tags.LIST_8:
                return this.readByte();
            case Constants_1.WA.Tags.LIST_16:
                return this.readInt(2);
            default:
                throw 'invalid tag for list size: ' + tag;
        }
    };
    Decoder.prototype.readString = function (tag) {
        if (tag >= 3 && tag <= 235) {
            var token = this.getToken(tag);
            return token === 's.whatsapp.net' ? 'c.us' : token;
        }
        switch (tag) {
            case Constants_1.WA.Tags.DICTIONARY_0:
            case Constants_1.WA.Tags.DICTIONARY_1:
            case Constants_1.WA.Tags.DICTIONARY_2:
            case Constants_1.WA.Tags.DICTIONARY_3:
                return this.getTokenDouble(tag - Constants_1.WA.Tags.DICTIONARY_0, this.readByte());
            case Constants_1.WA.Tags.LIST_EMPTY:
                return null;
            case Constants_1.WA.Tags.BINARY_8:
                return this.readStringFromChars(this.readByte());
            case Constants_1.WA.Tags.BINARY_20:
                return this.readStringFromChars(this.readInt20());
            case Constants_1.WA.Tags.BINARY_32:
                return this.readStringFromChars(this.readInt(4));
            case Constants_1.WA.Tags.JID_PAIR:
                var i = this.readString(this.readByte());
                var j = this.readString(this.readByte());
                if (i && j) {
                    return i + '@' + j;
                }
                throw 'invalid jid pair: ' + i + ', ' + j;
            case Constants_1.WA.Tags.HEX_8:
            case Constants_1.WA.Tags.NIBBLE_8:
                return this.readPacked8(tag);
            default:
                throw 'invalid string with tag: ' + tag;
        }
    };
    Decoder.prototype.readAttributes = function (n) {
        if (n !== 0) {
            var attributes = {};
            for (var i = 0; i < n; i++) {
                var key = this.readString(this.readByte());
                var b = this.readByte();
                attributes[key] = this.readString(b);
            }
            return attributes;
        }
        return null;
    };
    Decoder.prototype.readList = function (tag) {
        var _this = this;
        var arr = __spreadArrays(new Array(this.readListSize(tag)));
        return arr.map(function () { return _this.readNode(); });
    };
    Decoder.prototype.getToken = function (index) {
        if (index < 3 || index >= Constants_1.WA.SingleByteTokens.length) {
            throw 'invalid token index: ' + index;
        }
        return Constants_1.WA.SingleByteTokens[index];
    };
    Decoder.prototype.getTokenDouble = function (index1, index2) {
        var n = 256 * index1 + index2;
        if (n < 0 || n > Constants_1.WA.DoubleByteTokens.length) {
            throw 'invalid double token index: ' + n;
        }
        return Constants_1.WA.DoubleByteTokens[n];
    };
    Decoder.prototype.readNode = function () {
        var listSize = this.readListSize(this.readByte());
        var descrTag = this.readByte();
        if (descrTag === Constants_1.WA.Tags.STREAM_END) {
            throw 'unexpected stream end';
        }
        var descr = this.readString(descrTag);
        if (listSize === 0 || !descr) {
            throw 'invalid node';
        }
        var attrs = this.readAttributes((listSize - 1) >> 1);
        var content = null;
        if (listSize % 2 === 0) {
            var tag = this.readByte();
            if (this.isListTag(tag)) {
                content = this.readList(tag);
            }
            else {
                var decoded = void 0;
                switch (tag) {
                    case Constants_1.WA.Tags.BINARY_8:
                        decoded = this.readBytes(this.readByte());
                        break;
                    case Constants_1.WA.Tags.BINARY_20:
                        decoded = this.readBytes(this.readInt20());
                        break;
                    case Constants_1.WA.Tags.BINARY_32:
                        decoded = this.readBytes(this.readInt(4));
                        break;
                    default:
                        decoded = this.readString(tag);
                        break;
                }
                if (descr === 'message' && Buffer.isBuffer(decoded)) {
                    content = Constants_1.WA.Message.decode(decoded);
                }
                else {
                    content = decoded;
                }
            }
        }
        return [descr, attrs, content];
    };
    Decoder.prototype.read = function (buffer) {
        this.buffer = buffer;
        this.index = 0;
        return this.readNode();
    };
    return Decoder;
}());
exports.default = Decoder;
